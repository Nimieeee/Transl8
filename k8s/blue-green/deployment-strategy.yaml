# Blue-Green Deployment Strategy for Model Services
# This configuration enables zero-downtime model version updates

---
# Blue Deployment (Current/Stable Version)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: whisper-pyannote-stt-blue
  namespace: ai-models
  labels:
    app: whisper-pyannote-stt
    version: blue
    component: stt
spec:
  replicas: 2
  selector:
    matchLabels:
      app: whisper-pyannote-stt
      version: blue
  template:
    metadata:
      labels:
        app: whisper-pyannote-stt
        version: blue
        component: stt
    spec:
      # Same spec as whisper-pyannote-stt.yaml
      priorityClassName: high-priority
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: nvidia.com/gpu
                    operator: Exists
      tolerations:
        - key: nvidia.com/gpu
          operator: Exists
          effect: NoSchedule
      containers:
        - name: whisper-pyannote
          image: your-registry/whisper-pyannote:v1.0  # Current stable version
          # ... rest of container spec

---
# Green Deployment (New Version)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: whisper-pyannote-stt-green
  namespace: ai-models
  labels:
    app: whisper-pyannote-stt
    version: green
    component: stt
spec:
  replicas: 0  # Start with 0, scale up during deployment
  selector:
    matchLabels:
      app: whisper-pyannote-stt
      version: green
  template:
    metadata:
      labels:
        app: whisper-pyannote-stt
        version: green
        component: stt
    spec:
      priorityClassName: high-priority
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: nvidia.com/gpu
                    operator: Exists
      tolerations:
        - key: nvidia.com/gpu
          operator: Exists
          effect: NoSchedule
      containers:
        - name: whisper-pyannote
          image: your-registry/whisper-pyannote:v2.0  # New version
          # ... rest of container spec

---
# Service pointing to active deployment (blue by default)
apiVersion: v1
kind: Service
metadata:
  name: whisper-pyannote-stt-active
  namespace: ai-models
  labels:
    app: whisper-pyannote-stt
spec:
  type: ClusterIP
  ports:
    - port: 8000
      targetPort: 8000
      protocol: TCP
      name: http
  selector:
    app: whisper-pyannote-stt
    version: blue  # Switch to 'green' to activate new version

---
# Service for testing green deployment before switching
apiVersion: v1
kind: Service
metadata:
  name: whisper-pyannote-stt-preview
  namespace: ai-models
  labels:
    app: whisper-pyannote-stt
spec:
  type: ClusterIP
  ports:
    - port: 8000
      targetPort: 8000
      protocol: TCP
      name: http
  selector:
    app: whisper-pyannote-stt
    version: green

---
# ConfigMap for deployment automation script
apiVersion: v1
kind: ConfigMap
metadata:
  name: blue-green-deploy-script
  namespace: ai-models
data:
  deploy.sh: |
    #!/bin/bash
    set -e
    
    SERVICE_NAME=$1
    NEW_VERSION=$2
    NAMESPACE="ai-models"
    
    echo "Starting blue-green deployment for $SERVICE_NAME to version $NEW_VERSION"
    
    # Get current active version
    CURRENT_VERSION=$(kubectl get service ${SERVICE_NAME}-active -n $NAMESPACE -o jsonpath='{.spec.selector.version}')
    echo "Current active version: $CURRENT_VERSION"
    
    # Determine new version color
    if [ "$CURRENT_VERSION" == "blue" ]; then
      NEW_COLOR="green"
      OLD_COLOR="blue"
    else
      NEW_COLOR="blue"
      OLD_COLOR="green"
    fi
    
    echo "Deploying to $NEW_COLOR environment"
    
    # Update green/blue deployment with new image
    kubectl set image deployment/${SERVICE_NAME}-${NEW_COLOR} \
      -n $NAMESPACE \
      ${SERVICE_NAME}=${NEW_VERSION}
    
    # Scale up new version
    echo "Scaling up $NEW_COLOR deployment"
    kubectl scale deployment/${SERVICE_NAME}-${NEW_COLOR} \
      -n $NAMESPACE \
      --replicas=2
    
    # Wait for new version to be ready
    echo "Waiting for $NEW_COLOR deployment to be ready"
    kubectl rollout status deployment/${SERVICE_NAME}-${NEW_COLOR} \
      -n $NAMESPACE \
      --timeout=10m
    
    # Run health checks on preview service
    echo "Running health checks on preview service"
    PREVIEW_IP=$(kubectl get service ${SERVICE_NAME}-preview -n $NAMESPACE -o jsonpath='{.spec.clusterIP}')
    
    for i in {1..10}; do
      if curl -f http://${PREVIEW_IP}:8000/health; then
        echo "Health check passed"
        break
      fi
      if [ $i -eq 10 ]; then
        echo "Health checks failed, rolling back"
        kubectl scale deployment/${SERVICE_NAME}-${NEW_COLOR} -n $NAMESPACE --replicas=0
        exit 1
      fi
      sleep 5
    done
    
    # Switch traffic to new version
    echo "Switching traffic to $NEW_COLOR"
    kubectl patch service ${SERVICE_NAME}-active \
      -n $NAMESPACE \
      -p "{\"spec\":{\"selector\":{\"version\":\"${NEW_COLOR}\"}}}"
    
    # Wait for traffic to stabilize
    echo "Waiting for traffic to stabilize (30s)"
    sleep 30
    
    # Scale down old version
    echo "Scaling down $OLD_COLOR deployment"
    kubectl scale deployment/${SERVICE_NAME}-${OLD_COLOR} \
      -n $NAMESPACE \
      --replicas=0
    
    echo "Blue-green deployment completed successfully"
    echo "Active version is now: $NEW_COLOR"
    
  rollback.sh: |
    #!/bin/bash
    set -e
    
    SERVICE_NAME=$1
    NAMESPACE="ai-models"
    
    echo "Rolling back $SERVICE_NAME"
    
    # Get current active version
    CURRENT_VERSION=$(kubectl get service ${SERVICE_NAME}-active -n $NAMESPACE -o jsonpath='{.spec.selector.version}')
    echo "Current active version: $CURRENT_VERSION"
    
    # Determine rollback version
    if [ "$CURRENT_VERSION" == "blue" ]; then
      ROLLBACK_COLOR="green"
    else
      ROLLBACK_COLOR="blue"
    fi
    
    echo "Rolling back to $ROLLBACK_COLOR"
    
    # Scale up rollback version
    kubectl scale deployment/${SERVICE_NAME}-${ROLLBACK_COLOR} \
      -n $NAMESPACE \
      --replicas=2
    
    # Wait for rollback version to be ready
    kubectl rollout status deployment/${SERVICE_NAME}-${ROLLBACK_COLOR} \
      -n $NAMESPACE \
      --timeout=5m
    
    # Switch traffic
    kubectl patch service ${SERVICE_NAME}-active \
      -n $NAMESPACE \
      -p "{\"spec\":{\"selector\":{\"version\":\"${ROLLBACK_COLOR}\"}}}"
    
    # Scale down current version
    kubectl scale deployment/${SERVICE_NAME}-${CURRENT_VERSION} \
      -n $NAMESPACE \
      --replicas=0
    
    echo "Rollback completed successfully"
    echo "Active version is now: $ROLLBACK_COLOR"

---
# Job for automated blue-green deployment
apiVersion: batch/v1
kind: Job
metadata:
  name: blue-green-deploy-job
  namespace: ai-models
spec:
  template:
    spec:
      serviceAccountName: deployment-manager
      containers:
        - name: deploy
          image: bitnami/kubectl:latest
          command: ["/bin/bash"]
          args:
            - -c
            - |
              # Source the deployment script
              source /scripts/deploy.sh
              
              # Deploy service (set via env vars)
              deploy.sh $SERVICE_NAME $NEW_VERSION
          env:
            - name: SERVICE_NAME
              value: "whisper-pyannote-stt"
            - name: NEW_VERSION
              value: "your-registry/whisper-pyannote:v2.0"
          volumeMounts:
            - name: scripts
              mountPath: /scripts
      volumes:
        - name: scripts
          configMap:
            name: blue-green-deploy-script
            defaultMode: 0755
      restartPolicy: Never
  backoffLimit: 2

---
# ServiceAccount for deployment automation
apiVersion: v1
kind: ServiceAccount
metadata:
  name: deployment-manager
  namespace: ai-models

---
# Role for deployment automation
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: deployment-manager-role
  namespace: ai-models
rules:
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "patch", "update"]
  - apiGroups: ["apps"]
    resources: ["deployments/scale"]
    verbs: ["get", "patch", "update"]
  - apiGroups: [""]
    resources: ["services"]
    verbs: ["get", "list", "patch", "update"]
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]

---
# RoleBinding for deployment automation
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: deployment-manager-binding
  namespace: ai-models
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: deployment-manager-role
subjects:
  - kind: ServiceAccount
    name: deployment-manager
    namespace: ai-models
